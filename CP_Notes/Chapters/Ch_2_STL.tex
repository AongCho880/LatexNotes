\newpage
\chapter{The C++ Standard Template Library (STL)}
\section{\textbf{What is STL ?}}

The C++ Standard Template Library (STL) is a collection of algorithms, data structures, and other components that can be used to simplify the development of C++ programs. The STL provides a range of containers, such as vectors, lists, and maps, as well as algorithms for searching, sorting and manipulating data.

\vspace{0.5cm}

\textbf{STL has 4 components:}
\begin{enumerate}
	\item Algorithms
	\item Containers
	\item Function Objects or Functors
	\item Iterators
\end{enumerate}

%%%%%%%%%%%%%%%%%%%%%% STL Containers %%%%%%%%%%%%%%%%%%%%%%
\section{\textbf{Containers in C++ STL}}
A container is a holder object that stores a collection of other objects (its elements). They are implemented as class templates, which allows great flexibility in the types supported as elements.\\
The container manages the storage space for its elements and provides member functions to access them, either directly or through iterators (reference objects with similar properties to pointers).
\newpage
\begin{table}[!h]
	\begin{center}
	\caption{Containers}
	\resizebox{\textwidth}{!}{%
		\begin{tabular}{ c | c | c | c }

		\toprule
		\textbf{\makecell[c]{Sequence \\ Containers}}
		& \textbf{\makecell[c]{Associative \\ Containers}}
		& \textbf{\makecell[c]{Unordered Associative \\ Containers }}
		& \textbf{\makecell[c]{Container \\ Adapters}} \\
		\hline
	
		Array & Set & Unordered Set & Stack \\
		Vector & Map & Unordered Map & Queue \\
		Deque & Multiset & Unordered Multiset & Priority Queue \\
		Forward List & Multimap & Unordered Multimap & --- \\
		List & --- & --- & --- \\
		\hline
	
		\end{tabular}
	}
	\end{center}
\end{table}

\textbf{\textcolor{red}{\large{Note:}}} All STL containers are passed by value.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Sequence Containers}
Sequence containers implement data structures that can be accessed sequentially. 
\begin{itemize}
	\item \textbf{\underline{array:}} Static contiguous array (class template)
	\item \textbf{\underline{vector:}} Dynamic contiguous array (class template)
	\item \textbf{\underline{deque:}} Double-ended queue (class template)
	\item \textbf{\underline{forward-list:}} Singly-linked list (class template)
	\item \textbf{\underline{list:}}  Doubly-linked list (class template)
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Associative Containers}
Associative containers implement sorted data structures that can be quickly searched ($O(\log{n})$ complexity). 
\begin{itemize}
	\item \textbf{\underline{set:}} Collection of unique keys, sorted by keys (class template)
	\item \textbf{\underline{map:}} Collection of key-value pairs, sorted by keys, keys are unique (class template).
	\item \textbf{\underline{multiset:}} Collection of keys, sorted by keys (class template)
	\item \textbf{\underline{multimap:}} Collection of key-value pairs, sorted by keys 
(class template)
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Unordered associative containers}
Unordered associative containers implement unsorted (hashed) data structures that can be quickly searched (O(1) amortized, O(n) worst-case complexity). 
\begin{itemize}
	\item \textbf{\underline{unordered\_set:}} Collection of unique keys, hashed by keys. (class template)
	\item \textbf{\underline{unordered\_map:}} Collection of key-value pairs, hashed by keys, keys are unique. (class template)
	\item \textbf{\underline{unordered\_multiset:}} Collection of keys, hashed by keys (class template)
	\item \textbf{\underline{unordered\_multimap:}} Collection of key-value pairs, hashed by keys (class template)
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Container Adapters}
Container adapters provide a different interface for sequential containers.
\begin{itemize}
	\item \textbf{\underline{atack:}} Adapts a container to provide stack (LIFO data structure) (class template).
	\item \textbf{\underline{queue:}} Adapts a container to provide queue (FIFO data structure) (class template).
	\item \textbf{\underline{priority\_queue:}} Adapts a container to provide priority queue (class template). 
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%% rand() and srand() in C++ %%%%%%%%%%%%%
\section{\textbf{rand() in C++}}
\textcolor{violet}{\texttt{rand()}} function is an inbuilt function in C++ STL, which is defined in header file \textcolor{violet}{\texttt{<cstdlib>}}. rand() is used to generate a series of random numbers. The random number is generated by using an algorithm that gives a series of non-related numbers whenever this function is called. The \textcolor{violet}{\texttt{rand()}} function is used in C++ to generate random numbers in the range \textcolor{violet}{\texttt{[0, RAND\_MAX)}}.

\begin{itemize}
	\item This function does not take any parameters;
	\item Time Complexity O(1)
	\item Space Complexity O(1)
\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%% Array STL %%%%%%%%%%%%%%%%%%%
\newpage
\section{\textbf{Array STL}}
The \texttt{array} is a collection of homogeneous objects and this array container is defined for constant size arrays or (static size). This container wraps around fixed-size arrays and the information of its size are not lost when declared to a pointer. 
In order to utilize arrays, we need to include the array header: 
\textcolor{cyan}{\texttt{\#include <array>}} \\

\textbf{Syntax:} \textcolor{violet}{\texttt{array<object\_type, arr\_size> arr\_name;}}

\begin{itemize}
	\item \textbf{Pass by value:}\\ \textcolor{violet}{\texttt{void updateArray(array<object\_type,arr\_size) array\_name\{\\ \tab Code;\\ \}}}
	
	\item \textbf{Pass by reference:}\\ \textcolor{violet}{\texttt{void updateArray(array<object\_type,arr\_size) \textcolor{red}{\&}array\_name\{\\ \tab Code;\\ \}}}
\end{itemize}

%%%%%%%%%%%%%%%%%%%%
\subsection{Operations on Array}
\begin{itemize}
	\item \textbf{\textcolor{cyan}{size()} Function:} This method returns the maximum size of the array.\\
	\textcolor{violet}{\texttt{arrayname.size()\\ Parameters : No parameters are passed.\\  Returns : Number of elements in the container.}}
	
	\item \textbf{\textcolor{cyan}{fill(val)} Function:} This method is used to fill the array with \texttt{val}\\ \textcolor{violet}{\texttt{fill(arr\_name.begin()+indx, arr\_name.end()-indx,val)}}
	
	\item \textbf{Sorting Array:} \\ Include header \textcolor{violet}{\texttt{\#include<algorithm>}} \\
	\textcolor{violet}{\texttt{sort(arr\_name.begin(),arr\_name.end())}}
\end{itemize}


%%%%%%%%%%%%%%%%%%%% Vector STL %%%%%%%%%%%%%%%%%%%%
\newpage
\section{\textbf{Vector STL}}
Dynamic array with the ability to re-size itself automatically when an element is inserted\\
Contiguous store locations, reallocation happens when underlying array is full.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Vector Constructor}
Ways of defining a vector-\\
	\tab\tab\textcolor{violet}{\texttt{\#include<vector>}}
\begin{itemize}
	\item[{\LARGE$\diamond$}] Empty container constructor\\
		\tab\textcolor{violet}{\texttt{vector<data\_type> vector\_name}}
		
	\item[{\LARGE$\diamond$}] Fill constructor (5 integers with 10 value)\\
		\tab\textcolor{violet}{\texttt{vector<int> numbers(5,10)}}
		
	\item[{\LARGE$\diamond$}] Range constructor\\
		\tab\textcolor{violet}{\texttt{int num[] = \{10, 20, 30, 40\}}}\\
		\tab\textcolor{violet}{\texttt{vector<int> numbers(num,num+4)}}
		
	\item[{\LARGE$\diamond$}] Copy constructor\\
		\tab\textcolor{violet}{\texttt{vector<int> copy\_num(numbers)}}
\end{itemize}

%%%%%%%%%%%%%%% Vector Methods
\subsection{Basic Vector Methods}

\begin{center}
	\textbf{Iterators:}
\end{center}
\begin{itemize}

	\item[{\LARGE $\diamond$}] \textbf{[ \textcolor{violet}{\texttt{begin()}} ]:} Returns an iterator pointing to the first element of vector. $O(1)$
	
	\item[{\LARGE $\diamond$}] \textbf{[ \textcolor{violet}{\texttt{end()}} ]:} Returns an iterator pointing to the element behind the last element of vector.	$O(1)$
	
\end{itemize}

%%%%%%%%%%%%%
\begin{center}
	\textbf{Accessing the elements:}
\end{center}
\begin{itemize}

	\item[{\LARGE $\diamond$}] \textbf{[ \textcolor{violet}{\texttt{at(index)}} ]:} Returns a reference to element at position `index'. $O(1)$
	
	\item[{\LARGE $\diamond$}] \textbf{[ \textcolor{violet}{\texttt{front()}} ]:} Returns a reference to first element.	$O(1)$
	
	\item[{\LARGE $\diamond$}] \textbf{[ \textcolor{violet}{\texttt{back()}} ]:} Returns a reference to last element.	$O(1)$
	
\end{itemize}

%%%%%%%%%%%%%
\begin{center}
	\textbf{Capacity:}
\end{center}
\begin{itemize}
	
	\item[{\LARGE $\diamond$}] \textbf{[ \textcolor{violet}{\texttt{size()}} ]:} Returns the number of elements in the vector. $O(1)$
	
	\item[{\LARGE $\diamond$}] \textbf{[ \textcolor{violet}{\texttt{max\_size()}} ]:} Returns the maximum number of elements that the vector can hold. $O(1)$
	
	\item[{\LARGE $\diamond$}] \textbf{[ \textcolor{violet}{\texttt{capacity()}} ]:} Returns the size of the storage space currently allocated. $O(1)$
	
	\item[{\LARGE $\diamond$}] \textbf{[ \textcolor{violet}{\texttt{resize(n)}} ]:} Re-sizes the container so that it contains `n' elements. $O(n)$
	
	\item[{\LARGE $\diamond$}] \textbf{[ \textcolor{violet}{\texttt{empty()}} ]:} Returns whether the container is empty. $O(1)$
	
\end{itemize}

%%%%%%%%%%%%%
\begin{center}
	\textbf{Modifiers:}
\end{center}
\begin{itemize}

	\item[{\LARGE $\diamond$}] \textbf{[ \textcolor{violet}{\texttt{push\_back()}} ]:} Inserts the elements into a vector from the back. $O(1)$
	
	\item[{\LARGE $\diamond$}] \textbf{[ \textcolor{violet}{\texttt{pop\_back()}} ]:} Removes the last element from the vector. $O(1)$
	
	\item[{\LARGE $\diamond$}] \textbf{[ \textcolor{violet}{\texttt{insert()}} ]:} Inserts new elements before the position specified by the iterator. $Linear$ $O(n)$\\
	\tab Syntax:\tab \textbf{\textcolor{violet}{\texttt{vectorName.insert(position, val)}}}
	
	\item[{\LARGE $\diamond$}] \textbf{[ \textcolor{violet}{\texttt{erase()}} ]:} Remove elements from a container form the specified position or range. $Linear$ $O(n)$\\
	\tab Syntax:\tab \textbf{\textcolor{violet}{\texttt{vectorName.erase(position)}}}\\
	\tab Syntax:\tab \textbf{\textcolor{violet}{\texttt{vectorName.erase(startPos, endPos)}}}
	
	\item[{\LARGE $\diamond$}] \textbf{[ \textcolor{violet}{\texttt{clear()}} ]:} Remove all the elements of the container. $Linear$ $O(n)$
	
	\item[{\LARGE $\diamond$}] \textbf{[ \textcolor{violet}{\texttt{assign()}} ]:} It assigns a new value to the vector elements by replacing old ones. $Linear$ $O(n)$\\
	\tab The syntax for assigning constant values:\\
	\tab \textbf{\textcolor{violet}{\texttt{vectorName.assign(int size, int value)}}}\\
	
	\tab The syntax for assigning values from an array:\\
	\tab \textbf{\textcolor{violet}{\texttt{vectorName.assign(arr, arr+size)}}}\\
	
	\item[{\LARGE$\diamond$}] \textbf{Vector reserve() method} \\
		\tab\textcolor{violet}{\texttt{arr.reserve(size)}}\\
		The C++ reserve() function helps us reserve a vector capacity. This capacity must be enough to contain n number of elements. This function can help us increase the capacity of any given vector with a value greater than or equal to the new capacity, which we will specify in the reserve function.
	
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\subsection{Sorting Vector}

\begin{lstlisting}[language=c++]
#include <iostream>
#include <algorithm>
#include <vector>
using namespace std;

int main() {
    vector <int> nums{6,4,1,3,5};
    // Ascending Order
    sort(nums.begin(),nums.end());
    // Descending Order
    sort(nums.begin(),nums.end(),greater<>());   
    return 0;
}

\end{lstlisting}


%%%%%%%%%%%%%%%%%%%%% Pair %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\section{\textbf{Pair}}
Pair is a container that stores two data elements in it. It is not necessary that the two values or data elements have to be of the same data  type.\\
\tab Syntax:\tab \textbf{\textcolor{violet}{\texttt{pair<dataType1,dataType2>pairName}}}

%%%%%%%%%%%%%%%%%%
\subsection{Pair Initialization}
\begin{itemize}
	\item[{\LARGE $\diamond$}] \textbf{\textcolor{violet}{\texttt{pairName = make\_pair(1,"Name")}}}
	
	\item[{\LARGE $\diamond$}] \textbf{\textcolor{violet}{\texttt{pair pairName(1,"Name")}}}
\end{itemize}

%%%%%%%%%%%%%%%%%%%%
\subsection{Methods}
\begin{itemize}
	\item[{\LARGE $\diamond$}] \textbf{[ \textcolor{violet}{\texttt{pairName.first}} ]:} Returns the first element of the pair. $O(1)$
	
	\item[{\LARGE $\diamond$}] \textbf{[ \textcolor{violet}{\texttt{pairName.second}} ]:} Returns the second element of the pair. $O(1)$
	
	\item[{\LARGE $\diamond$}]	\textbf{[ \textcolor{violet}{\texttt{pair1.swap(pair2}} ]:} Swaps the contents of one pair object with the contents of the another pair object. The pair must be of the same type.
	
\end{itemize}


%%%%%%%%%%%%%%%%% Vector of Pairs %%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\section{\textbf{Vector of Pairs}}
Vector of Pairs is a dynamic array filled with pairs instead of any primitive data type.

\begin{itemize}
	
	\item[{\LARGE $\diamond$}]	\textbf{Declaration:}\\
		\tab\tab \textbf{\textcolor{violet}{\texttt{vector<pair<int,string>>p1;}}}
		
	\item[{\LARGE $\diamond$}]	\textbf{Add an item:}\\
		\tab\tab \textbf{\textcolor{violet}{\texttt{p1.push\_back(make\_pair(1,"aaa"));}}}
		\begin{center}
			or
		\end{center}
		\tab\tab \textbf{\textcolor{violet}{\texttt{p1.emplace\_back(1,"aaa");}}}
		
	\item[{\LARGE $\diamond$}]	\textbf{Delete an item:}\\
		\tab Delete Last Pair:\tab \textbf{\textcolor{violet}{\texttt{p1.pop\_back();}}}\\
		\tab Delete $i^{th}$ Pair:\tab \textbf{\textcolor{violet}{\texttt{p1.erase(a.begin()+i);}}}
	
\end{itemize}

%%%%%%%%%%%%%%%%%%%	
\subsection{Sorting the vector of pair}
\subsubsection{Make vector of pairs}

\begin{lstlisting}[language=c++]

#include <iostream>
#include <algorithm>
#include <vector>
using namespace std;

int main() {
    vector <int> arr1{5,3,1,6,5};
    vector <int> arr2{10,2,7,3,5};
    vector <pair<int,int>> vp;

    for(int i=0; i<arr1.size(); i++)
        vp.push_back(make_pair(arr1[i],arr2[i]));
    
    return 0;
}

\end{lstlisting}

\subsubsection{Sort on the basis of first element of pairs ascending order}
\begin{lstlisting}[language=c++]

sort(vp.begin(), vp.end());

\end{lstlisting}

\subsubsection{Sort on the basis of first element of pairs descending order}
\begin{lstlisting}[language=c++]

sort(vp.rbegin(), vp.rend());

\end{lstlisting}

\subsubsection{Sort on the basis of second element of pairs ascending order}
\begin{lstlisting}[language=c++]
// Create the sortBySec() function outside of the main() function.

bool sortBySec(const pair<int,int> &a, const pair<int,int> &b) {
	return (a.second < b.second);
}

// Now sort the vector of pair inside the main() function.
sort(vp.begin(), vp.end(), sortBySec);

\end{lstlisting}

\subsubsection{Sort on the basis of second element of pairs descending order}
\begin{lstlisting}[language=c++]

sort(vp.rbegin(), vp.rend(), sortBySec);

\end{lstlisting}


%%%%%%%%%%%%%%%%%%%% SET %%%%%%%%%%%%%%%%%
\newpage
\section{\textbf{SET STL}}
Sets are a type of associative container in which each element has to be unique because the value of the element identifies it. The values are stored in a specific sorted order i.e. either ascending or descending.

\begin{lstlisting}[language=c++]

#include <iostream>
#include <algorithm>
#include <set>
using namespace std;

void show(set<char, greater<char>> &S) {
    for(auto i:S) cout << i << endl;
}

int main() {
    string str = "92341778065310";
    set <char> S;
    set <char, greater<char>> T;
    
    // Insert elements into the set in ascending order 
    for(auto i:str) S.insert(i);
    cout << "Ascending Order:\n";
    for(auto i:S) cout << i << endl;

    // Copy & Store elements into a set in descending order
    set <char,greater<char>> S1(S.begin(), S.end());
    cout << "Descending Order:\n";
    show(S1);

    // Insert elements into a set in descending order
    for(auto i: str) T.insert(i);
    cout << "Value of T:\n";
    show(T);

    return 0;
}

\end{lstlisting}


%%%%%%%%%%%%%%%%%%%% Double-ended Queue %%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\section{\textbf{Double-ended Queue (deque)}}
Deque is sequence containers with dynamic sizes that can be expanded or contracted on both ends (front or back)\\
deques are not guaranteed to store all its elements in contiguous storage locations: accessing elements in deque by offsetting a pointer to another element causes undefined behavior.\\
Elements of a deque can be scattered in different chunks of storage.\\
Header file:\\
	\tab \tab \textcolor{cyan}{\texttt{\#include<deque>}}

%%%%%%%%%%%%%%%
\subsection{Syntax to creating a deque object}
	\tab \tab \textcolor{cyan}{\texttt{deque<object\_type> deque\_name;}}\\
	
\textbf{Create a deque:}
\begin{itemize}
	\item[{\LARGE $\diamond$}] Empty deque of ints \\
		\tab \textcolor{violet}{\texttt{deque<int> arr1;}}
	\item[{\LARGE $\diamond$}] Four ints with value 100 \\
		\tab \textcolor{violet}{\texttt{deque<int> arr2(4,100);}}
	\item[{\LARGE $\diamond$}] Copy using iterators \\
		\tab \textcolor{violet}{\texttt{deque<int> arr3(arr2.begin(),arr2.end());}}
	\item[{\LARGE $\diamond$}] Full Copy \\
		\tab \textcolor{violet}{\texttt{deque<int> arr4(arr3);}}
\end{itemize}	

%%%%%%%%%%%%%%%%
\subsection{Deque Methods}

\begin{itemize}
	\item[{\LARGE $\diamond$}]\textbf{\texttt{arr.insert[iterator\_position,value]:}} Insert value at iterator\_position.
	\item[{\LARGE $\diamond$}]\textbf{\texttt{arr[index]:}} Access index value.
	\item[{\LARGE $\diamond$}]\textbf{\texttt{arr.at(index):}} Access index value.
	\item[{\LARGE $\diamond$}]\textbf{\texttt{arr.size():}} It returns the number of elements.
	\item[{\LARGE $\diamond$}]\textbf{\texttt{push\_back():}} It adds a new element at the end of the container.
	\item[{\LARGE $\diamond$}]\textbf{\texttt{push\_front():}} It adds a new element at the beginning of the container.
	\item[{\LARGE $\diamond$}]\textbf{\texttt{pop\_back():}} It deletes the last element from the deque.
	\item[{\LARGE $\diamond$}]\textbf{\texttt{pop\_front():}} It deletes the first element from the deque.
	
\end{itemize}




%%%%%%%%%%%%%%%%%%%%%%%%% STACK %%%%%%%%%%%%%%%%%%%%%
\newpage
\section{STACK}
The stack data structure follows the \emph{LIFO} (Last In First Out) principle. That is, the element added last will be removed first.

%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Create a Stack}
In order to create a stack in C++, we first need to include the \textbf{\textcolor{violet}{\texttt{stack}}} header file.\\
\tab Header:\tab \textbf{\textcolor{violet}{\texttt{\#include<stack>}}}\\
\tab Syntax:\tab \textbf{\textcolor{violet}{\texttt{stack<type>st}}}\\

%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Methods of Stack}
In C++, the \textbf{\textcolor{violet}{\texttt{stack}}} class provides various methods to perform different operations on a stack.

\begin{itemize}

	\item[{\LARGE $\diamond$}] \textbf{[ \textcolor{violet}{\texttt{push()}} ]:} Adds an element at the top of the stack. $O(1)$\\
	\tab Syntax:\tab \textbf{\textcolor{violet}{\texttt{st.push(element);}}}
	
	\item[{\LARGE $\diamond$}] \textbf{[ \textcolor{violet}{\texttt{pop()}} ]:} Removes an element from the top of the stack. $O(1)$\\
	\tab Syntax:\tab \textbf{\textcolor{violet}{\texttt{st.pop();}}}
	
	\item[{\LARGE $\diamond$}] \textbf{[ \textcolor{violet}{\texttt{top()}} ]:} Returns the element at the top of the stack. $O(1)$\\
	\tab Syntax:\tab \textbf{\textcolor{violet}{\texttt{st.top();}}}
	
	\item[{\LARGE $\diamond$}] \textbf{[ \textcolor{violet}{\texttt{size()}} ]:} Returns the number of the elements in the stack. $O(1)$\\
	\tab Syntax:\tab \textbf{\textcolor{violet}{\texttt{st.size();}}}
	
	\item[{\LARGE $\diamond$}] \textbf{[ \textcolor{violet}{\texttt{empty()}} ]:} Returns \textbf{\textcolor{violet}{\texttt{true}}} if the stack is empty. $O(1)$\\
	\tab Syntax:\tab \textbf{\textcolor{violet}{\texttt{st.empty();}}}
	
\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%% Queue %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\section{Queue}
The Queue data structure follows the \textbf{FIFO (First In First Out)} principle where elements that are added first will be removed first.

%%%%%%%%%%%%%%%%%%
\subsection{Create Queue}
Include header file\\
\tab \tab \textbf{\textcolor{violet}{\texttt{\#include <queue>}}}\\
Syntax to create Queue:\\
\tab \tab \textbf{\textcolor{violet}{\texttt{queue <dataType> q;}}}

%%%%%%%%%%%%%%%%%%
\subsection{Queue Methods}
\begin{itemize}

	\item[{\LARGE $\diamond$}] \textbf{[ \texttt{push()} ]:} Insert an element at the end of the queue. $O(1)$\\
	\tab \textbf{\textcolor{violet}{\texttt{q.push(element);}}}
	
	\item[{\LARGE $\diamond$}] \textbf{[ \texttt{pop()} ]:} Removes an element from the front of the queue. $O(1)$\\
	\tab \textbf{\textcolor{violet}{\texttt{q.pop();}}}
	
	\item[{\LARGE $\diamond$}] \textbf{[ \texttt{front()} ]:} Returns the first element of the queue. $O(1)$\\
	\tab \textbf{\textcolor{violet}{\texttt{q.front();}}}
	
	\item[{\LARGE $\diamond$}] \textbf{[ \texttt{back()} ]:} Returns the last element of the queue. $O(1)$\\
	\tab \textbf{\textcolor{violet}{\texttt{q.back();}}}
	
	\item[{\LARGE $\diamond$}] \textbf{[ \texttt{size()} ]:} Returns the number of elements in the queue. $O(1)$\\
	\tab \textbf{\textcolor{violet}{\texttt{q.size();}}}
	
	\item[{\LARGE $\diamond$}] \textbf{[ \texttt{empty()} ]:} Returns \texttt{true} if the queue is empty. $O(1)$\\
	\tab \textbf{\textcolor{violet}{\texttt{q.empty();}}}
	
\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%% Priority Queue %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\section{Priority Queue}
A priority queue is a special type of queue in which each element is associated with a priority value. And, elements are served on the basis of their priority. That is, higher priority elements are served first.\\
However, if elements with the same priority occur, they are served according to their order in the queue.

%%%%%%%%%%%%%%%%%%
\subsection{Create Priority Queue}
Include header file\\
\tab \tab \textbf{\textcolor{violet}{\texttt{\#include <queue>}}}\\
Syntax to create Priority Queue:\\
\tab \tab \textbf{\textcolor{violet}{\texttt{priority\_queue <dataType> pq;}}}

%%%%%%%%%%%%%%%%%%
\subsection{Priority Queue Methods}
\begin{itemize}

	\item[{\LARGE $\diamond$}] \textbf{[ \texttt{push()} ]:} Insert an element in to the priority queue. $O(log(N))$\\
	\tab \textbf{\textcolor{violet}{\texttt{pq.push(element);}}}
	
	\item[{\LARGE $\diamond$}] \textbf{[ \texttt{pop()} ]:} Removes the element with highest priority. $O(log(N))$\\
	\tab \textbf{\textcolor{violet}{\texttt{pq.pop();}}}
	
	\item[{\LARGE $\diamond$}] \textbf{[ \texttt{top()} ]:} Returns the element with highest priority. $O(1)$\\
	\tab \textbf{\textcolor{violet}{\texttt{pq.top();}}}
	
	\item[{\LARGE $\diamond$}] \textbf{[ \texttt{size()} ]:} Returns the number of elements. $O(1)$\\
	\tab \textbf{\textcolor{violet}{\texttt{pq.size();}}}
	
	\item[{\LARGE $\diamond$}] \textbf{[ \texttt{empty()} ]:} Returns \texttt{true} if the   priority\_queue is empty. $O(1)$\\
	\tab \textbf{\textcolor{violet}{\texttt{pq.empty();}}}
	
\end{itemize}

%%%%%%%%%%%% Min-Heap Priority Queue
\subsection{Min-Heap Priority-Queue}
We can also create a \textbf{min-heap} \textcolor{violet}{\texttt{priority\_queue}} that arranges elements in ascending order. Its syntax is:\\
\tab \textbf{\textcolor{violet}{\texttt{priority\_queue<type, vector<type>, greater<type>> pq;}}}

